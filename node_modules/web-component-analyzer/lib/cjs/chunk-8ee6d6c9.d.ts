import { Program, TypeChecker, Type, SourceFile, Node, CallExpression, Expression, ObjectLiteralExpression, JSDocTag } from "typescript";
import { AnalyzerResult } from "./analyzer-result-4b787b76";
import { TransformerConfig } from "./transformer-config-8314091f";
import { ComponentMethod } from "./component-method-8314091f";
import { ComponentDeclaration, ComponentFeatures } from "./component-declaration-f9a1dfdf";
import { VisibilityKind } from "./visibility-kind-8314091f";
import { SimpleType } from "ts-simple-type";
import { AnalyzerOptions } from "./analyzer-options-fd82e405";
import { AnalyzerVisitContext } from "./analyzer-visit-context-2c0df8a3";
import { AnalyzerFlavor, FeatureVisitReturnTypeMap, DefinitionNodeResult, AnalyzerDeclarationVisitContext, ComponentFeatureCollection, ComponentMemberResult, FeatureDiscoverVisitMap } from "./analyzer-flavor-2c0df8a3";
import { ComponentFeature } from "./component-feature-cb6a2ade";
import { ComponentDefinition } from "./component-definition-08b1aefc";
import { InheritanceTreeNode, InheritanceTreeClause } from "./inheritance-tree-f9a1dfdf";
import { ComponentCssPart } from "./component-css-part-c0c96ec8";
import { ComponentCssProperty } from "./component-css-property-bf4b003a";
import { ComponentEvent } from "./component-event-8314091f";
import { ComponentSlot } from "./component-slot-cb6a2ade";
import { JsDoc, JsDocTagParsed } from "./js-doc-e1edf5c6";
import { ModifierKind } from "./modifier-kind-d7983be2";
import { LitElementPropertyConfig } from "./lit-element-property-config-a6e5ad36";
import { TransformerKind } from "./transformer-kind-cc0d5aa9";
type TransformerFunction = (results: AnalyzerResult[], program: Program, config: TransformerConfig) => string;
declare const vscodeTransformer: TransformerFunction;
declare const markdownTransformer: TransformerFunction;
declare function markdownHeader(title: string, level: number, config: TransformerConfig): string;
declare function markdownTable(rows: string[][], { removeEmptyColumns }?: {
    removeEmptyColumns: boolean;
}): string;
declare function markdownEscapeTableCell(text: string): string;
declare function markdownHighlight(text: string | undefined): string;
declare function fillWidth(text: string, width: number, paddingStart: number): string;
declare function getTypeHintFromMethod(method: ComponentMethod, checker: TypeChecker): string | undefined;
interface Example {
    lang?: string;
    code: string;
    description?: string;
}
declare function getExamplesFromComponent(declaration: ComponentDeclaration): Example[];
declare const jsonTransformer: TransformerFunction;
declare function getFirst<T>(set: Set<T>): T | undefined;
declare function filterVisibility<T extends {
    visibility?: VisibilityKind;
}>(visibility: VisibilityKind, array: T[]): T[];
declare function getTypeHintFromType(type: string | Type | SimpleType | undefined, checker: TypeChecker): string | undefined;
declare const debugJsonTransformer: TransformerFunction;
declare function analyzeSourceFile(sourceFile: SourceFile, options: AnalyzerOptions): AnalyzerResult;
declare function discoverGlobalFeatures(node: Node, context: AnalyzerVisitContext): ComponentFeatures;
type VisitFeatureEmitMap = {
    [K in ComponentFeature]: (result: FeatureVisitReturnTypeMap[K][]) => void;
};
declare function visitGlobalFeatures<ReturnType>(node: Node, context: AnalyzerVisitContext, emitMap: Partial<VisitFeatureEmitMap>): void;
declare function discoverDefinitions(sourceFile: SourceFile, context: AnalyzerVisitContext, analyzeDeclaration: (definition: ComponentDefinition, declarationNodes: Node[]) => ComponentDeclaration): ComponentDefinition[];
declare function visitDefinitions(node: Node, context: AnalyzerVisitContext, emit: (results: DefinitionNodeResult[]) => void): void;
declare function refineDeclaration(declaration: ComponentDeclaration, context: AnalyzerDeclarationVisitContext): ComponentDeclaration;
declare function excludeNode(node: Node, context: AnalyzerVisitContext): boolean;
declare function discoverInheritance(startNode: Node | Node[], context: AnalyzerVisitContext): InheritanceTreeNode;
declare function visitInheritance(node: Node, context: AnalyzerVisitContext, emit: (results: InheritanceTreeClause[]) => void, visitSet?: Set<Node>): void;
declare function executeFunctionsUntilMatch<T extends Partial<Record<K, any>>, K extends keyof T, ReturnValue extends ReturnType<NonNullable<T[K]>>, ArgType>(functionMaps: T[], keys: K | K[], arg: ArgType, context: AnalyzerVisitContext): {
    value: NonNullable<ReturnValue>;
    shouldContinue?: boolean;
} | undefined;
declare function discoverFeatures(node: Node, context: AnalyzerDeclarationVisitContext): ComponentFeatureCollection;
declare function mergeMemberResults(memberResults: ComponentMemberResult[], context: AnalyzerVisitContext): ComponentMemberResult[];
declare function mergeSlots(slots: ComponentSlot[]): ComponentSlot[];
declare function mergeCssParts(cssParts: ComponentCssPart[]): ComponentCssPart[];
declare function mergeCssProperties(cssProps: ComponentCssProperty[]): ComponentCssProperty[];
declare function mergeMethods(methods: ComponentMethod[]): ComponentMethod[];
declare function mergeEvents(events: ComponentEvent[]): ComponentEvent[];
declare function mergeJsDoc(leftJsDoc: JsDoc | undefined, rightJsDoc: JsDoc | undefined): JsDoc | undefined;
declare function mergeModifiers(leftModifiers: Set<ModifierKind> | undefined, rightModifiers: Set<ModifierKind> | undefined): Set<ModifierKind> | undefined;
declare function mergeNamedEntries<T>(entries: T[], getName: (entry: T) => string, merge?: (left: T, right: T) => T): T[];
declare function mergeEntries<T>(entries: T[], isMergeable: (entry: T, merged: T) => boolean, merge: (left: T, right: T) => T): T[];
type RefineFeatureEmitMap = {
    [K in ComponentFeature]: (result: FeatureVisitReturnTypeMap[K]) => void;
};
declare function refineFeature<FeatureKind extends ComponentFeature, ValueType = FeatureVisitReturnTypeMap[FeatureKind]>(featureKind: FeatureKind, value: ValueType | ValueType[], context: AnalyzerVisitContext, emitMap: Partial<RefineFeatureEmitMap>): void;
declare function prepareRefineEmitMap(): {
    collection: ComponentFeatureCollection;
    refineEmitMap: RefineFeatureEmitMap;
};
declare function discoverDefinitions$0(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare function discoverMembers(node: Node, context: AnalyzerDeclarationVisitContext): ComponentMemberResult[] | undefined;
declare function excludeNode$0(node: Node, context: AnalyzerVisitContext): boolean | undefined;
declare class LitElementFlavor implements AnalyzerFlavor {
    excludeNode: typeof excludeNode$0;
    discoverDefinitions: typeof discoverDefinitions$0;
    discoverFeatures: {
        member: typeof discoverMembers;
    };
    refineFeature: Partial<import("./analyzer-flavor-2c0df8a3").FeatureRefineVisitMap> | undefined;
}
declare const refineFeature$0: AnalyzerFlavor["refineFeature"];
type LitElementPropertyDecoratorKind = "property" | "internalProperty";
declare const LIT_ELEMENT_PROPERTY_DECORATOR_KINDS: LitElementPropertyDecoratorKind[];
declare function getLitElementPropertyDecorator(node: Node, context: AnalyzerVisitContext): {
    expression: CallExpression;
    kind: LitElementPropertyDecoratorKind;
} | undefined;
declare function getLitElementPropertyDecoratorConfig(node: Node, context: AnalyzerVisitContext): undefined | LitElementPropertyConfig;
declare function getLitPropertyOptions(node: ObjectLiteralExpression, context: AnalyzerVisitContext, existingConfig?: LitElementPropertyConfig): LitElementPropertyConfig;
declare function parseLitPropertyOption({ kind, initializer, config }: {
    kind: string | undefined;
    initializer: Expression;
    config: LitElementPropertyConfig;
}, context: AnalyzerVisitContext): LitElementPropertyConfig;
declare function discoverDefinitions$1(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare class JSXFlavor implements AnalyzerFlavor {
    discoverDefinitions: typeof discoverDefinitions$1;
    discoverGlobalFeatures: Partial<import("./analyzer-flavor-2c0df8a3").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>> | undefined;
}
declare const discoverGlobalFeatures$0: AnalyzerFlavor["discoverGlobalFeatures"];
declare function discoverDefinitions$2(node: Node, context: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare function refineDeclaration$0(declaration: ComponentDeclaration, context: AnalyzerVisitContext): {
    deprecated: string | boolean;
    inheritanceTree: import("./api").InheritanceTreeNode;
    declarationNodes: Set<import("typescript").Node>;
    jsDoc: import("./api").JsDoc | undefined;
    members: import("./api").ComponentMember[];
    methods: import("./api").ComponentMethod[];
    events: import("./api").ComponentEvent[];
    slots: import("./api").ComponentSlot[];
    cssProperties: import("./api").ComponentCssProperty[];
    cssParts: import("./api").ComponentCssPart[];
} | undefined;
declare class JsDocFlavor implements AnalyzerFlavor {
    discoverDefinitions: typeof discoverDefinitions$2;
    discoverFeatures: Partial<import("./analyzer-flavor-2c0df8a3").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>>;
    discoverGlobalFeatures: Partial<import("./analyzer-flavor-2c0df8a3").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>> | undefined;
    refineFeature: Partial<import("./analyzer-flavor-2c0df8a3").FeatureRefineVisitMap> | undefined;
    refineDeclaration: typeof refineDeclaration$0;
}
declare const refineFeature$1: AnalyzerFlavor["refineFeature"];
declare const discoverGlobalFeatures$1: AnalyzerFlavor["discoverGlobalFeatures"];
declare const discoverFeatures$0: Partial<FeatureDiscoverVisitMap<AnalyzerVisitContext>>;
declare function parseJsDocForNode<T>(node: Node, tagNames: string[], transform: (tagNode: JSDocTag | undefined, parsed: JsDocTagParsed) => T | undefined, context: AnalyzerVisitContext): T[] | undefined;
declare function discoverDefinitions$3(node: Node, { ts, checker }: AnalyzerVisitContext): DefinitionNodeResult[] | undefined;
declare function discoverEvents(node: Node, context: AnalyzerVisitContext): ComponentEvent[] | undefined;
declare function discoverInheritance$0(node: Node, context: AnalyzerVisitContext): InheritanceTreeClause[] | undefined;
declare function discoverMembers$0(node: Node, context: AnalyzerDeclarationVisitContext): ComponentMemberResult[] | undefined;
declare function discoverMethods(node: Node, context: AnalyzerDeclarationVisitContext): ComponentMethod[] | undefined;
declare function excludeNode$1(node: Node, context: AnalyzerVisitContext): boolean | undefined;
declare class CustomElementFlavor implements AnalyzerFlavor {
    excludeNode: typeof excludeNode$1;
    discoverDefinitions: typeof discoverDefinitions$3;
    discoverFeatures: {
        member: typeof discoverMembers$0;
        event: typeof discoverEvents;
        method: typeof discoverMethods;
    };
    discoverGlobalFeatures: Partial<import("./analyzer-flavor-2c0df8a3").FeatureDiscoverVisitMap<import("./api").AnalyzerVisitContext>> | undefined;
    refineFeature: Partial<import("./analyzer-flavor-2c0df8a3").FeatureRefineVisitMap> | undefined;
    discoverInheritance: typeof discoverInheritance$0;
}
declare const refineFeature$2: AnalyzerFlavor["refineFeature"];
declare function relaxType(type: SimpleType): SimpleType;
declare const discoverGlobalFeatures$2: AnalyzerFlavor["discoverGlobalFeatures"];
interface HtmlDataValue {
    name: string;
    description?: string;
}
interface HtmlDataValueSet {
    name: string;
    values: HtmlDataValueSet[];
}
interface HtmlDataMember {
    name: string;
    description?: string;
    values?: HtmlDataValue[];
    valueSet?: string;
    type?: unknown;
    attribute?: string;
    deprecated?: boolean;
    deprecatedMessage?: string;
}
interface HtmlDataAttribute extends HtmlDataMember {
    default?: string;
}
interface HtmlDataProperty extends HtmlDataMember {
    default?: string;
}
interface HtmlDataSlot extends HtmlDataMember {
}
interface HtmlDataEvent extends HtmlDataMember {
}
interface HtmlDataCssProperty extends HtmlDataMember {
    default?: string;
}
interface HtmlDataCssPart extends HtmlDataMember {
}
interface HtmlDataTag {
    name: string;
    description?: string;
    attributes?: HtmlDataAttribute[];
    path?: string;
    properties?: HtmlDataProperty[];
    slots?: HtmlDataSlot[];
    events?: HtmlDataEvent[];
    cssProperties?: HtmlDataCssProperty[];
    cssParts?: HtmlDataCssPart[];
    deprecated?: boolean;
    deprecatedMessage?: string;
}
interface HtmlDataV2 {
    version: string;
    tags?: HtmlDataTag[];
    valueSets?: HtmlDataValueSet[];
    global?: {
        attributes?: HtmlDataMember[];
        properties?: HtmlDataMember[];
        slots?: HtmlDataMember[];
        events?: HtmlDataMember[];
    };
}
type HtmlData = HtmlDataV2;
interface HtmlDataAttrValue {
    name: string;
    description?: string;
}
interface HtmlDataAttr {
    name: string;
    description?: string;
    values?: HtmlDataAttrValue[];
    valueSet?: string;
}
interface HtmlDataTag$0 {
    name: string;
    description?: string;
    attributes: HtmlDataAttr[];
}
interface HtmlDataValueSet$0 {
    name: string;
    values: HtmlDataAttrValue[];
}
interface HtmlDataV1 {
    version: 1;
    tags?: HtmlDataTag$0[];
    globalAttributes?: HtmlDataAttr[];
    valueSets?: HtmlDataValueSet$0[];
}
type VscodeHtmlData = HtmlDataV1;
/**
 * Transforms the analyzer results into a string representation based on the transformer kind
 * @param kind
 * @param results
 * @param program
 * @param config
 */
declare function transformAnalyzerResult(kind: TransformerKind, results: AnalyzerResult | AnalyzerResult[], program: Program, config?: Partial<TransformerConfig>): string;
export { vscodeTransformer, markdownTransformer, markdownHeader, markdownTable, markdownEscapeTableCell, markdownHighlight, fillWidth, getTypeHintFromMethod, Example, getExamplesFromComponent, jsonTransformer, getFirst, filterVisibility, getTypeHintFromType, debugJsonTransformer, analyzeSourceFile, discoverGlobalFeatures, visitGlobalFeatures, discoverDefinitions, visitDefinitions, refineDeclaration, excludeNode, discoverInheritance, visitInheritance, executeFunctionsUntilMatch, discoverFeatures, mergeMemberResults, mergeSlots, mergeCssParts, mergeCssProperties, mergeMethods, mergeEvents, mergeJsDoc, mergeModifiers, mergeNamedEntries, mergeEntries, RefineFeatureEmitMap, refineFeature, prepareRefineEmitMap, LitElementFlavor, LitElementPropertyDecoratorKind, LIT_ELEMENT_PROPERTY_DECORATOR_KINDS, getLitElementPropertyDecorator, getLitElementPropertyDecoratorConfig, getLitPropertyOptions, parseLitPropertyOption, JSXFlavor, JsDocFlavor, parseJsDocForNode, CustomElementFlavor, relaxType, HtmlDataValue, HtmlDataValueSet, HtmlDataMember, HtmlDataAttribute, HtmlDataProperty, HtmlDataSlot, HtmlDataEvent, HtmlDataCssProperty, HtmlDataCssPart, HtmlDataTag, HtmlDataV2, HtmlData, HtmlDataAttrValue, HtmlDataAttr, HtmlDataV1, VscodeHtmlData, transformAnalyzerResult };
//# sourceMappingURL=chunk-8ee6d6c9.d.ts.map